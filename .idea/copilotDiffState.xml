<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/road_back/src/main/java/com/road/project/road_back/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/road_back/src/main/java/com/road/project/road_back/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.road.project.road_back.config;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.AuthenticationProvider;&#10;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;&#10;/**&#10; * Configuration de la sécurité Spring Security.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableMethodSecurity(prePostEnabled = true)&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final JwtAuthenticationFilter jwtAuthenticationFilter;&#10;    private final CustomUserDetailsService userDetailsService;&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .csrf(AbstractHttpConfigurer::disable)&#10;                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        // Routes publiques&#10;                        .requestMatchers(&quot;/api/auth/register&quot;, &quot;/api/auth/login&quot;, &quot;/api/auth/refresh&quot;).permitAll()&#10;                        .requestMatchers(&quot;/api/auth/unlock/**&quot;).permitAll()&#10;                        .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/api-docs/**&quot;, &quot;/swagger-ui.html&quot;).permitAll()&#10;                        .requestMatchers(&quot;/api/map/tiles/**&quot;, &quot;/api/map/config&quot;).permitAll()&#10;                        // Routes pour les signalements (lecture publique)&#10;                        .requestMatchers(HttpMethod.GET, &quot;/api/signalements/**&quot;).permitAll()&#10;                        .requestMatchers(HttpMethod.GET, &quot;/api/signalements/stats&quot;).permitAll()&#10;                        // Routes protégées pour Manager&#10;                        .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;MANAGER&quot;)&#10;                        .requestMatchers(HttpMethod.DELETE, &quot;/api/signalements/**&quot;).hasRole(&quot;MANAGER&quot;)&#10;                        // Toutes les autres routes nécessitent une authentification&#10;                        .anyRequest().authenticated()&#10;                )&#10;                .authenticationProvider(authenticationProvider())&#10;                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);&#10;&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(List.of(&quot;http://localhost:5173&quot;, &quot;http://localhost:3000&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;PATCH&quot;));&#10;        configuration.setAllowedHeaders(List.of(&quot;*&quot;));&#10;        configuration.setAllowCredentials(true);&#10;        configuration.setExposedHeaders(List.of(&quot;Authorization&quot;));&#10;&#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationProvider authenticationProvider() {&#10;        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();&#10;        authProvider.setUserDetailsService(userDetailsService);&#10;        authProvider.setPasswordEncoder(passwordEncoder());&#10;        return authProvider;&#10;    }&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {&#10;        return config.getAuthenticationManager();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.road.project.road_back.config;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.AuthenticationProvider;&#10;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;&#10;/**&#10; * Configuration de la sécurité Spring Security.&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableMethodSecurity(prePostEnabled = true)&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final JwtAuthenticationFilter jwtAuthenticationFilter;&#10;    private final CustomUserDetailsService userDetailsService;&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .csrf(AbstractHttpConfigurer::disable)&#10;                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))&#10;                .authorizeHttpRequests(auth -&gt; auth&#10;                        // Routes publiques&#10;                        .requestMatchers(&quot;/api/auth/register&quot;, &quot;/api/auth/login&quot;, &quot;/api/auth/refresh&quot;).permitAll()&#10;                        .requestMatchers(&quot;/api/auth/unlock/**&quot;).permitAll()&#10;                        .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/api-docs/**&quot;, &quot;/swagger-ui.html&quot;).permitAll()&#10;                        .requestMatchers(&quot;/api/map/tiles/**&quot;, &quot;/api/map/config&quot;).permitAll()&#10;                        // Routes pour les signalements (lecture publique)&#10;                        .requestMatchers(HttpMethod.GET, &quot;/api/signalements/**&quot;).permitAll()&#10;                        .requestMatchers(HttpMethod.GET, &quot;/api/signalements/stats&quot;).permitAll()&#10;                        // Routes protégées pour Manager&#10;                        .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;MANAGER&quot;)&#10;                        .requestMatchers(HttpMethod.DELETE, &quot;/api/signalements/**&quot;).hasRole(&quot;MANAGER&quot;)&#10;                        // Toutes les autres routes nécessitent une authentification&#10;                        .anyRequest().authenticated()&#10;                )&#10;                .authenticationProvider(authenticationProvider())&#10;                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);&#10;&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(List.of(&quot;http://localhost:5173&quot;, &quot;http://localhost:3000&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;PATCH&quot;));&#10;        configuration.setAllowedHeaders(List.of(&quot;*&quot;));&#10;        configuration.setAllowCredentials(true);&#10;        configuration.setExposedHeaders(List.of(&quot;Authorization&quot;));&#10;&#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationProvider authenticationProvider() {&#10;        // Spring Security 6 requires the UserDetailsService constructor&#10;        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider(userDetailsService);&#10;        authProvider.setPasswordEncoder(passwordEncoder());&#10;        return authProvider;&#10;    }&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {&#10;        return config.getAuthenticationManager();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>